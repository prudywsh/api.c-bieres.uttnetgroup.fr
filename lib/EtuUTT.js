const Request = require('request');
const Oauth2 = require('simple-oauth2');
const Url = require('url');

class EtuUTT {


    /**
     * Initiate the library
     * @param {object} options  Set options to configure lib behavior
     * @see EtuUTT.setOptions for `options` definition
     */
    constructor(options) {
        this.setOptions(options, true);
    }

    /**
     * Private assyncronous method that check token expiration en renew it if necessary
     * @param {callback} cb - Optionnal callback, promises are also supported
     */
    _checkToken(cb) {
        return new Promise((resolve, reject) => {
            let token = this.__oauth.accessToken.create({
                'access_token': this._accessToken,
                'refresh_token': this._refreshToken,
                'expires_at': this._tokenExpiration * 1000,
            });

            if (token.expired()) {
                token.refresh((error, result) => {
                    if(!error) {
                        this._accessToken = result.token.access_token;
                        this._refreshToken = result.token.refresh_token;
                        this._tokenExpiration = result.token.expires * 1000;
                        this._tokenRefreshCallback(this._accessToken, this._refreshToken, this._tokenExpiration / 1000);
                        resolve(result);
                    }
                    else {
                        reject(error);
                    }

                    if(typeof cb === 'function') {
                        cb(error, result);
                    }
                });
            }
            else {
                resolve(token);
                cb(null, token);
            }
        });
    }

    /**
     * setOptions - Set options to configure lib behavior
     *
     * @param  {Object} options     Options of the lib
     * @param  {boolean} reset    If true all not-given options will be reset
     *
     * @typedef {Object} options
     * @property {string} baseUri       Indicate the root uri of the api without a slash
     * @property {string} token         Token used to authenticate against API endpoints
     * @property {string} id            Application ID given by EtuUTT
     * @property {string} secret        Application Secret given by EtuUTT
     * @property {string|Array} scopes  The list of requested scopes as a string (separated by spaces) or as an array
     * @property {string} accessToken   The token that let you access the API (can be generated by Oauth)
     * @property {string} refreshToken  The token that let you refresh the main token in case of expiration (can be generated by Oauth)
     * @property {string} tokenExpiration   The timestamp (in seconds) of the main token expiration (can be generated by Oauth)
     * @property {function} tokenRefreshCallback The callback(accessToken, refreshToken, tokenExpiration) that will be called when the token is refreshed
     */
    setOptions(options, reset = false) {
        // Reset vars
        if(reset) {
            this._baseUri = 'https://etu.utt.fr/api';
            this._token = null;
            this._id = null;
            this._secret = null;
            this._scopes = null;
            this._accessToken = null;
            this._refreshToken = null;
            this._tokenExpiration = null;
            this.__oauth = null;
            this.__tokenObj = null;
            this._tokenRefreshCallback = () => {};
        }

        // set vars
        Object.keys(options).forEach((key) => {
            if(this.hasOwnProperty('_' + key)) {
                this['_' + key] = options[key];
            }
        });

        // Check vars
        if(typeof this._tokenRefreshCallback !== 'function') {
            this._tokenRefreshCallback = () => {};
        }

        // Transform vars
        if(Array.isArray(this._scopes)) {
            this._scopes = this._scopes.join(' ');
        }

        // Init Oauth
        if(this._id && this._secret && this._baseUri) {
            this.__oauth = Oauth2.create({
                client: {
                    id: this._id,
                    secret: this._secret,
                },
                auth: {
                    tokenHost: this._baseUri,
                    tokenPath: Url.parse(this._baseUri).pathname + '/oauth/token',
                    authorizePath: Url.parse(this._baseUri).pathname + '/oauth/authorize',
                }
            });
        }
    }

    /**
     * oauthAuthorize - Get the uri where the user should be redirect for oauth authorization_code.
     * @return An URI where the user should be redirect
     */
    oauthAuthorize() {
        return this.__oauth.authorizationCode.authorizeURL({
            scope: this._scopes,
        });
    }

    /**
     * oauthToken - Generate an token from an authorization_code which you get from oauthAuthorize()
     * @param {string} authorizationCode - The list of required scopes as a string (separated by spaces) or array
     * @param {callback} cb - Optionnal callback, promises are also supported
     * @return An URI where the user should be redirect
     */
    oauthTokenByAuthCode(authorizationCode) {
        return new Promise((resolve, reject) => {
            this.__oauth.authorizationCode.getToken({
                code: authorizationCode
            }, (error, result) => {

                if(!error) {
                    this._accessToken = result.access_token;
                    this._refreshToken = result.refresh_token;
                    this._tokenExpiration = result.expires_at;
                    resolve(result);
                }
                else {
                    reject(error);
                }

                if(typeof cb === 'function') {
                    cb(error, result);
                }
            });
        });
    }

    /**
     * publicUserAccount - Get public informations about connected user
     * @param {callback} cb - Optionnal callback, promises are also supported
     */
    publicUserAccount(cb) {
        if(typeof cb !== 'function') {
            cb = function(){};
        }
        return this._checkToken().then(() => {
            return new Promise((resolve, reject) => {
                Request({
                    url: this._baseUri + '/public/user/account',
                    method: 'GET',
                    headers: {
                        Authorization: ' Bearer ' + this._accessToken,
                    },
                }, function (error, response) {

                    if (!error && response.statusCode == 200) {
                        let object = JSON.parse(response.body);
                        resolve(object);
                        cb(null, object);
                    }
                    else if(!error){
                        reject(response);
                        cb(response);
                    }
                    else {
                        reject(error);
                        cb(error);
                    }
                });
            });
        });
    }


    /**
     * publicUsers - Find user-s and get public informations about them
     * @param {object} filters Associative object that containes filters
     * with firstname, lastname, branch, level, speciality, is_student,
     * bde_member, student_id, name, multifield as filter key
     * @param {callback} cb - Optionnal callback, promises are also supported
     * @return {promise} Promise to the list of found users
     */
    publicUsers(filters, cb) {
        if(typeof cb !== 'function') {
            cb = function(){};
        }
        return this._checkToken().then(() => {
            return new Promise((resolve, reject) => {
                Request({
                    url: this._baseUri + '/public/users',
                    method: 'GET',
                    headers: {
                        Authorization: ' Bearer ' + this._accessToken,
                    },
                    qs: filters
                }, function (error, response) {
                    if (!error && response.statusCode == 200) {
                        let object = JSON.parse(response.body);
                        resolve(object);
                        cb(null, object);
                    }
                    else if(!error){
                        reject(response);
                        cb(response);
                    }
                    else {
                        reject(error);
                        cb(error);
                    }
                });
            });
        });
    }

}


module.exports = EtuUTT;
